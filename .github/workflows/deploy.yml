# =============================================================================
# SYNCLEDGER - DEPLOY INFRASTRUCTURE & APPLICATION
# Uses Terraform to provision/update AWS resources and deploy containers
# =============================================================================

name: Deploy

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Deployment action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - plan-only
      environment:
        description: 'Target environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging

env:
  TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
  TF_VAR_environment: ${{ inputs.environment }}
  TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
  TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
  TF_VAR_ec2_key_name: ${{ vars.EC2_KEY_NAME || '' }}
  TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || '' }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}

permissions:
  contents: read
  packages: read

jobs:
  # ---- Terraform Plan ----
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    outputs:
      instance_ip: ${{ steps.plan_output.outputs.instance_ip }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.0"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: terraform
        run: |
          terraform plan \
            -input=false \
            -out=tfplan \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="jwt_secret=${{ secrets.JWT_SECRET }}"

      - name: Upload Plan
        if: inputs.action == 'deploy'
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: terraform/tfplan
          retention-days: 1

  # ---- Terraform Apply ----
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: inputs.action == 'deploy'
    environment: ${{ inputs.environment }}
    outputs:
      instance_ip: ${{ steps.outputs.outputs.instance_ip }}
      instance_id: ${{ steps.outputs.outputs.instance_id }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.0"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: terraform

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan

      - name: Get Outputs
        id: outputs
        working-directory: terraform
        run: |
          echo "instance_ip=$(terraform output -raw app_public_ip)" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw ec2_instance_id)" >> $GITHUB_OUTPUT

  # ---- Deploy Application ----
  deploy-app:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: inputs.action == 'deploy'
    environment: ${{ inputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Wait for instance to be ready
        run: |
          echo "Waiting for EC2 instance to initialize..."
          aws ec2 wait instance-status-ok \
            --instance-ids ${{ needs.terraform-apply.outputs.instance_id }} \
            --region ${{ env.AWS_REGION }} || true
          sleep 30

      - name: Deploy via SSM (no SSH key required)
        run: |
          INSTANCE_ID="${{ needs.terraform-apply.outputs.instance_id }}"
          OWNER="${{ github.repository_owner }}"
          
          # Create the deployment script
          DEPLOY_SCRIPT=$(cat <<'SCRIPT'
          #!/bin/bash
          set -euo pipefail
          
          cd /opt/syncledger
          
          # Login to GHCR
          echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
          
          # Update image references in compose file
          sed -i "s|ghcr.io/OWNER/|ghcr.io/${OWNER}/|g" docker-compose.prod.yml
          
          # Pull latest images
          docker-compose -f docker-compose.prod.yml pull
          
          # Deploy with zero-downtime
          docker-compose -f docker-compose.prod.yml up -d --remove-orphans
          
          # Cleanup old images
          docker image prune -af --filter "until=72h"
          
          echo "Deployment complete!"
          SCRIPT
          )
          
          # Execute via SSM Run Command
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"$DEPLOY_SCRIPT\"]" \
            --timeout-seconds 300 \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query "Command.CommandId" \
            2>/dev/null || echo "")
          
          if [ -z "$COMMAND_ID" ]; then
            echo "⚠️ SSM not available. Falling back to direct SSH..."
            echo "Please SSH into ${{ needs.terraform-apply.outputs.instance_ip }} and run deployment manually."
            echo ""
            echo "Commands to run on the server:"
            echo "  cd /opt/syncledger"
            echo "  docker-compose -f docker-compose.prod.yml pull"
            echo "  docker-compose -f docker-compose.prod.yml up -d"
          else
            echo "Waiting for deployment..."
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} || true
            
            # Get output
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} \
              --query '[StandardOutputContent, StandardErrorContent]' \
              --output text
          fi
        env:
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GHCR_USER: ${{ github.actor }}

      - name: Health Check
        run: |
          IP="${{ needs.terraform-apply.outputs.instance_ip }}"
          echo "Checking application health at http://$IP ..."
          
          for i in $(seq 1 12); do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$IP/api/actuator/health" || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "✅ Application is healthy!"
              exit 0
            fi
            echo "  Attempt $i/12 - HTTP $HTTP_CODE, retrying in 15s..."
            sleep 15
          done
          
          echo "⚠️ Health check didn't pass within 3 minutes."
          echo "The application may still be starting up."
          echo "Check: http://$IP"

      - name: Deployment Summary
        run: |
          echo ""
          echo "╔═══════════════════════════════════════════════════════════╗"
          echo "║           DEPLOYMENT COMPLETE                            ║"
          echo "╠═══════════════════════════════════════════════════════════╣"
          echo "║  Environment:  ${{ inputs.environment }}"
          echo "║  Instance:     ${{ needs.terraform-apply.outputs.instance_id }}"
          echo "║  Public IP:    ${{ needs.terraform-apply.outputs.instance_ip }}"
          echo "║  App URL:      http://${{ needs.terraform-apply.outputs.instance_ip }}"
          echo "║  API URL:      http://${{ needs.terraform-apply.outputs.instance_ip }}/api"
          echo "╚═══════════════════════════════════════════════════════════╝"
